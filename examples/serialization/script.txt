Game Engineering Engine Topics -

Here's a scenario: You're playing a game, and right before you get to that boss that wrecks you everytime, you quick save and continue.

Here's a scenario: You're playing a game, and 

Here's another: You're using your favorite video editing software, it crashes, you load it back up and it kindly asks if you want to resume where you left off.

This scenario shares something in common with most applications we all use: Serialization.

Today we're going to look at how a specific form of serialization, binary serialization, works and I'll show how we can use it to help create a small pixel art editor from scratch.

This is Game Engineering.

(Cue Title Shit)

As we saw in our previous examples, almost all applications, including games, employ some form of serialization, whether it's for saving game state, saving/loading assets, like textures, materials, or shaders, or 
	syncing data across a network for multiple people.

First, let's define some terms so we're all on the same page: 

What is binary serialization?

	- Binary Serialization involves taking some arbitrary set of structured data and transforming it into a homogenous, structured stream of bytes.
 
Why is it useful? 

	- Binary Serialization can be used for multiple purposes, such as: 
		- converting raw resource data into processed assets for your game
		- saving all game data for future play sessions, as we saw this the {game example}, this works for auto saves as well in applications that want to save your progress in case of crashes
		- streaming bytes across a network for multiplayer sessions

Let's look at how to implement a custom serialization mechanism in C for any data our game or applications might need to handle.

For this to work, we'll need three main components:
	
	- Ability to write arbitrary data into a homogenous, dynamic buffer of bytes
	- Ability to write data to binary file on disk
	- Ability to read data from file into buffer that can then be used to re-instantiate data

Again, for these examples, I'll be using the gunslinger library. However, we won't be using any of the defined data structures provided in the framework. We'll be writing everythign ourselves.

We're going to implement something called a "Byte Buffer". If you're familiar with higher level languages, like Java or C#, this this should be familiar to you. If not, then this is how a basic byte buffer is set up and works: 

A byte buffer is, very simply, an organized collection of homogeonous bytes. 
In our case, it will be represented like this: 

typedef struct byte_buffer_t
{
	uint8_t* data;
	uint32_t position;
	uint32_t size;
	uint32_t capacity;
} byte_buffer_t;

* We will systematically break complex structures apart and write their individual properties into this buffer, either one at a time
	or in bulk. 
* Then, upon request, we can read back out the same data to re-construct these objects in the future.

* Sounds great. But how is this done?

* Let's look at this texture as an example. 
* Here we have a 2d image, with a width and height of 4 pixels;
* Each pixel of the image is comprised of data for each channel depending on the number of components for that image.

(Anim for texture breaking into individual parts)

* Given this makeup, we can break this texture down into a structure made up of these properties: 

  - Width : 						uint32_t	4 bytes		<-
  - Height: 						uint32_t	4 bytes		<-
  - Number of Components per Pixel: uint32_t	4 bytes		<-
  - Texture GPU Format: 			uint32_t	4 bytes		<-
  - Array of Pixel Data: 			void*		width * height * num_comps bytes <-

 width * height * num_comps

* When serializing our texture, 
 	we will convert each of its properties into a stream of byte information, and add them one by one into our byte buffer.

* Once all of our object data is written into the buffer, it is said to be "serialized". We can now 
	save it to disk or do any number of things with it.

* To reconstruct our object, we just need to reverse the process and read back our the data in a specific way. 

* Let's see how that's done.

* First, we'll ask for the first 4 bytes to get our texture's width.We'll reset our byte buffer's position to the beginning of the buffer.

* Remembering how we wrote the data is important. We need to read back the exact byte information in the 
	order we placed it into the buffer, otherwise we'll get incorrect results and could potentially crash the
	application by reading invalid memory.

* Alright, let's remember our previous order, and we'll start to reconstruct our texture.

* Then we'll ask for the next 4 bytes for the height.
* Another 4 bytes for the number of components per pixel.
* And finally, we can ask for a bulk read of all of our actual pixel data using this formula for the byte size
	that needs to be read.

* With that, our texture can be fully re-constructed.

- Serialization: 
	- Byte Buffers
	- Writing game data
	- Loading game data from file



Outline: 
	
	Intro

	Byte Buffer Implementation

	Demo: Pixel Paint